using PLearning_Backend.Model;
using System.Collections.Generic;
using PLearning_Backend.Enumerations;
using PLearning_Backend.Structures;

COMPILER PLearning
 
	Dictionary<string, Procedure> procedureTable;			//Diccionario de procedimientos, la llave es el nombre del procedimiento
	List<string> procedureList;								//Lista que sirve para mapear los procedimientos con un numero
	List<Constant> constantTable;							//Lista de constantes

	Procedure actualProcedure;								//Apunta al procedimiento actual en el que se está
	int tipoActual;
	int scopeActual = VirtualStructure.VariableType.Global;	//Apunta al scope actual, global o local
	string programID;										//Nombre del programa

	Stack<int> POper = new Stack<int>();					//Pila de operadores para la generación de cuadruplos
	Stack<int> PilaOperandos = new Stack<int>();			//Pila de operandos para la generación de cuádruplos
	Stack<int> PTipos = new Stack<int>();					//Pila de tipos para la validación de semántica
	Stack<int> PSaltos = new Stack<int>();					//Pila de saltos para guardar los Jumps o la referencia a un Goto/GotoF
	Stack<string> PilaVarDim = new Stack<string>();			//Pila que guarda el nombre de las variables dimensionadas que se agregaron en la pila de operandos

	List<Quadruple> quadruples = new List<Quadruple>();		//Lista de los cuádruplos del programa


	/// <summary>
	/// Método que inserta un nuevo cuadruplo y lo mete a la lista de cuadruplos
	/// </summary>
	private void insertQuadruple(int opCode, int oper1, int oper2, int TemporalRegorJump)
	{
		Quadruple qAux = new Quadruple(opCode, oper1, oper2, TemporalRegorJump);
		quadruples.Add(qAux);
	}


	/// <summary>
    /// Método que sirve para intentar generar un cuádruplo de las expresiones, revisa que se
    /// pueda realizar la operación y si no, manda un error de semántica. 
    /// </summary>
	private void tryToGenerateQuadruple()
	{
		int operat = POper.Pop();				//Se saca el operador de la pila de operadores
		int operand2 = PilaOperandos.Pop();		//Se saca el operando del lado derecho de la pila de operandos
		int tipo2 = PTipos.Pop();				//Se saca el tipo del operando del lado derecho de la pila de tipos
		int operand1 = PilaOperandos.Pop();		//Se saca el operando del lado izquierdo de la pila de operandos
		int tipo1 = PTipos.Pop();				//Se saca el tipo del operando del lado izquierdo de la pila de tipos



		if (operand1 == -1 || operand2 == -1)
		{
			SemErr("Error - No se indexo la variable dimensionada.");
			finishExecution();

		}

		//Se obtiene el tipo resultante del cubo semántico al combinar ambos tipos con el operador
		int newType = SemanticCube.getCombiningType(tipo1, tipo2, operat);  

		//Se verifica que el tipo resultante no sea cero, es decir, que si se puedan combinar dichos tipos
		if (newType != 0)
		{
			int temp = VirtualStructure.getNext(VirtualStructure.VariableType.Temporal, newType); 	//Se obtiene la siguiente dirección temporal
			actualProcedure.increaseCounter(VirtualStructure.VariableType.Temporal, newType);	  	//Se incrementa el contador de tamaño de temporales					 	
			insertQuadruple(operat, operand1, operand2, temp); 										//Se genera un nuevo cuadruplo con los datos obtenidos		
			PilaOperandos.Push(temp);																//Se mete el temporal resultante a la pila de operandos
			PTipos.Push(newType);																	//Se mete el tipo resultante a a la pila de tipos
		}
		//Si no se pueden combinar
		else
		{
			//Se genera un error de semántica y se termina la ejecución
			SemErr("Error - Tipos incompatibles");
			finishExecution();
		}
	}

	/// <summary>
    /// Método que sirve para intentar insertar una variable en la pila de operandos 
    /// </summary>
	private Variable tryToInsertVariable()
	{
		//Si la variable no está en la tabla de variables del procedimiento correspondiente
		if (!actualProcedure.VariableTable.ContainsKey(t.val))
		{
			//Si la varaible no está en la tabla de variables del procedimiento global
			if (!procedureTable[programID].VariableTable.ContainsKey(t.val))
			{
				//Se genera un error de semántica
				SemErr("Variable no declarada");
				finishExecution();
			}
			//Si la variable se encuentra en la tabla de variables del procedimiento global
			else
			{
				//Se mete la dirección en la pila de operandos y el tipo en la pila de tipos.
				Variable v = procedureTable[programID].VariableTable[t.val];

				if (v.Dimensions.Count > 0)
				{
					PilaOperandos.Push(-1);
					PilaVarDim.Push(v.Name);

				}
				else
				{
					PilaOperandos.Push(v.VirtualDir);
				}
				
				PTipos.Push(v.Type);

				return v;
			}
			
		}
		//Si la variable si se encuentra en la tabla de variables del procedimiento actual
		else
		{
			//Se mete la dirección en la pila de operandos y el tipo en la pila de tipos.
			Variable v = actualProcedure.VariableTable[t.val];
			if (v.Dimensions.Count > 0)
			{
				PilaOperandos.Push(-1);
				PilaVarDim.Push(v.Name);

			}
			else
			{
				PilaOperandos.Push(v.VirtualDir);
			}
			PTipos.Push(v.Type);
			return v;
		}

		return null;
	}

	/// <summary>
    /// Método que sirve para intentar insertar una constante en la pila de operandos 
    /// </summary>
	private void tryToInsertConstant(int dataType, string val)
	{
		int virtualDir;							//Direccion virtual de la constante

		int index = constantTable.FindIndex(x => x.Name == val);

		//Si la constante ya se encuentra la lista
		if (index >= 0)
		{	
			//Se obtiene la dirección virtual
			virtualDir = constantTable[index].VirtualDir;
		}
		//Si no se encuentra en el diccionario
		else
		{
			//Se obtiene la dirección virtual de la estructura virtual
			virtualDir = VirtualStructure.getNext(VirtualStructure.VariableType.Constant, dataType);

			//Se crea la nueva constante
			Constant c = new Constant(val, virtualDir);

			//Se inserta en la tabla de constantes
			constantTable.Add(c);
		}
		
		//Se inserta la constante en la pila de operandos y en la pila de tipos
		PilaOperandos.Push(virtualDir);
		PTipos.Push(dataType);
	}

	private void tryToInsertArgument(int k, string id)
	{
		//Se saca el argumento junto con su tipo
		int argument = PilaOperandos.Pop();
		int argumentType = PTipos.Pop();

		//Si el tipo de argumento no el mismo con el definido, se marca error.
		if (k < procedureTable[id].Parameters.Count)
		{
			if (argumentType != procedureTable[id].Parameters[k].Type)
			{
				SemErr("Error - Los tipos no coinciden con la función");
				finishExecution();
			}

			Variable v = null;
			if (argument == -1)
			{
				v = actualProcedure.VariableTable[PilaVarDim.Pop()];

				if (procedureTable[id].Parameters[k].Dimensions.Count != v.Dimensions.Count)
				{
					SemErr("Error - El numero de dimensiones en el parametro no coincide con lo declarado");
					finishExecution();
				}

				int i = 0;
				int tam = 1;
				foreach (Dimension d in procedureTable[id].Parameters[k].Dimensions)
				{
					if (d.Dim != v.Dimensions[i].Dim)
					{
						SemErr("Error - El tamaño de la matriz dimensionada tiene que ser igual al declarado.");
						finishExecution();
					}

					tam *= d.Dim;
					i++;
				}

				//Se añade un nuevo cuadruplo "Param" con el numero de procedimiento
				insertQuadruple(OperationCode.Param, v.VirtualDir, tam, procedureTable[id].Parameters[k].VirtualDir);					



			}
			else
			{
				//Se añade un nuevo cuadruplo "Param" con el numero de procedimiento
				insertQuadruple(OperationCode.Param, argument, -1, procedureTable[id].Parameters[k].VirtualDir);
			}

				
			
		}
		else
		{
			SemErr("El numero de parametros no coindice con la declaración de la función");
		}
	}

	///<summary>
	/// Método que sirve para encontrar el numero de procedimiento
	///</summary>
	private int findProcedure(string name)
	{
		for (int i = 0; i < procedureList.Count; i++)
		{
			if (procedureList[i] == name)
			{
				return i;
			}			
		}

		return -1;
	}

	private void processDimension(int dim, Dimension d, Variable vDim)
	{

		if (PTipos.Peek() != DataType.Int)
		{
			SemErr("Error - El indexamiento para arreglos necesita ser de tipo entero.");
			finishExecution();
		}

		insertQuadruple(OperationCode.Verify, PilaOperandos.Peek(), -1, d.Dim);

		if (dim + 1 < vDim.Dimensions.Count)
		{
			int s = PilaOperandos.Pop();
			int sTipo = PTipos.Pop();

			if (s == -1)
			{
				SemErr("Error - No se indexo la variable dimensionada.");
				finishExecution();
			}

			int vTemp = VirtualStructure.getNext(VirtualStructure.VariableType.Temporal, DataType.Int);
			actualProcedure.increaseCounter(VirtualStructure.VariableType.Temporal, DataType.Int);

			tryToInsertConstant(DataType.Int, d.M.ToString());

			int virtualDir = PilaOperandos.Pop();
			PTipos.Pop();

			insertQuadruple(OperationCode.Multiplication, s, virtualDir, vTemp);
			PilaOperandos.Push(vTemp);
			PTipos.Push(DataType.Int);

			
		}

		if (dim > 0)
		{
			int aux2 = PilaOperandos.Pop();
			int aux1 = PilaOperandos.Pop();

			int tAux2 = PTipos.Pop();
			int tAux1 = PTipos.Pop();

			int vTemp2 = VirtualStructure.getNext(VirtualStructure.VariableType.Temporal, DataType.Int);
			actualProcedure.increaseCounter(VirtualStructure.VariableType.Temporal, DataType.Int);

			insertQuadruple(OperationCode.Sum, aux1, aux2, vTemp2);

			PilaOperandos.Push(vTemp2);
			PTipos.Push(DataType.Int);

		}
	}

	///<summary>
	/// Método que sirve para finalizar la ejecución del programa.
	///</summary>
	private void finishExecution()
	{
		Console.ReadLine();
		Environment.Exit(1);
	}


/*--------------------------------------------------------------------------*/
CHARACTERS
	letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
	digit = "0123456789".
	eol                = '\u000a'. /* 10 = line feed */
	cr  = '\r'.
	newLine = cr + eol. 
	char = ANY - "'" - '\\' - newLine.
	stringT = ANY - '"'.
	lf  = '\n'.
	tab = '\t'.
	ws = ' '.

TOKENS
	ID = letter { letter | digit }.
	CTEENTERA = digit {digit}.
	CTEFLOAT = digit {digit} "." digit {digit}.
	CTESTRING = '"' { stringT } '"'.
	CTECHAR = '\'' char '\''.
	PROGRAM  = "program".
	MAIN = "main".
	VOID = "void".
	INT = "int".
	FLOAT = "float".
	STRING = "string".
	BOOL = "bool".
	CHAR = "char".
	IFF = "if".
	ELSE = "else".
	AND = "and".
	OR = "or".
	WHILE = "while".
	FOR = "for".
	RETURN = "return".
	PRINT = "print".
	READLINE = "readLine".
	FUNCTION = "function".
	TRUE = "true".
	FALSE = "false".
	REF = "ref".
	PYC = ";".
	COMA = ",".
	IGUAL = "=".
	PARAB = "(".
	PARCI = ")".
	LLAVEAB = "{".
	LLAVECI = "}".
	CORCHAB = "[".
	CORCHCI = "]".
	MAS = "+".
	MENOS = "-".
	MULT = "*".
	DIV = "/".
	MAQUE = ">".
	MEQUE = "<".
	MAQUEEQ = ">=".
	MEQUEEQ = "<=".
	DIFERENTE = "!=".
	COMPARACION = "==".


IGNORE cr + lf + tab



PRODUCTIONS
/*------------------------------------------------------------------------*/
/*---------------------------------------------- PLEARNING ---------------------------------------------- */
PLearning = PROGRAM
	(. 
		procedureTable = new Dictionary<string, Procedure>();			//Se inicializa la tabla de procedimientos
		procedureList = new List<string>();								//Se inicializa la lista de procedimientos
		constantTable = new List<Constant>(); 							//Se inicializa la lista de constantes
	.)
 ID
 	(. 
 		actualProcedure = new Procedure(t.val, ReturnType.Program);		//Se asgian como procedimiento actual al procedimiento global
 		procedureTable.Add(t.val, actualProcedure);   					//Se añade este procedimiento a la tabla de procedimientos
 		procedureList.Add(t.val);										//Se añade también a la lista de procedimientos
 		programID = t.val;												//Se asigna el id del programa para uso posterior
	.) 
PYC {vars}
	(.
		scopeActual = VirtualStructure.VariableType.Local;				//Se asigna el scope como local cuando se acaba lo primero
		PSaltos.Push(quadruples.Count);									//Añade en la pila de saltos la posición en donde estará el goto al main
		insertQuadruple(OperationCode.Goto, -1, -1, -1);
	.)
 {funcion} main
	(.
		insertQuadruple(OperationCode.EndProg, -1, -1, -1);
	.)
 .

/*---------------------------------------------- VARS ---------------------------------------------- */
vars = tipo
	(. 

		List<int> registros = new List<int>();		//Lista de registros que sirve para asignar las variables que tienen asignación inicial
 		tipoActual = DataType.toDataType(t.val); 	//Se guarda el tipo en una variable
 	.)
(ID 
	(.
		//Si la variable ya estaba declarada anteriormente, se genera un error
		if (actualProcedure.VariableTable.ContainsKey(t.val))
		{
			SemErr("Error - Variable " + t.val + " previamente declarada");
		}
		//Si no estaba declarada
		else
		{
			//Se asigna una nueva dirección virtual
			int virtualDir = VirtualStructure.getNext(scopeActual, tipoActual);
			//Se añade a la lista de registros
			registros.Add(virtualDir);
			//Se añade la nueva variable a la tabla de variables del procedimiento en cuestión
			actualProcedure.VariableTable.Add(t.val, new Variable(t.val, tipoActual, virtualDir));
			//Se incrementa el contador de tamaño correspondiente
			actualProcedure.increaseCounter(VirtualStructure.VariableType.Local, tipoActual);
		}
  	.)
{COMA ID
 	(.
 		//Pasa lo mismo que en lo anterior si hay mas variables
 		if (actualProcedure.VariableTable.ContainsKey(t.val))
		{
			SemErr("Error - Variable '" + t.val + "' previamente declarada");
		}
		else
		{
			int virtualDir = VirtualStructure.getNext(scopeActual, tipoActual);
			registros.Add(virtualDir);
			actualProcedure.VariableTable.Add(t.val, new Variable(t.val, tipoActual, virtualDir));
			actualProcedure.increaseCounter(VirtualStructure.VariableType.Local, tipoActual);
		} 
	.)
 } [IGUAL (ctelet | ctenum | ctebool)
	(.
		//Se recorren todos los registros para asigna el valor a todas las variables que se declararon
		foreach (int r in registros)
		{

			int index = constantTable.FindIndex(x => x.Name == t.val);
			insertQuadruple(OperationCode.Assignment, constantTable[index].VirtualDir, -1, r);
		}

	.)

 ] 

|
CORCHAB CTEENTERA
	(.
		List<int> dimensions = new List<int>();
		int dim = int.Parse(t.val);
		dimensions.Add(dim);
		int r = dim;
	.)
[ COMA CTEENTERA 
	(.
		dim = int.Parse(t.val);
		dimensions.Add(dim);
		r *= dim;
	.)
[ COMA CTEENTERA
	(.
		dim = int.Parse(t.val);
		dimensions.Add(dim);
		r *= dim;
	.)
] ] CORCHCI 
 ID
  (.
  		int tam = r;
  		//Si la variable dimensionada se encuentra en la tabla de variables se marca error
		if (actualProcedure.VariableTable.ContainsKey(t.val))
		{
			SemErr("Error - Variable '" + t.val + "' previamente declarada");
		}

		//Si no, entonces se añade a la tabla de variables
		else
		{
			Variable vDim = new Variable(t.val, tipoActual, VirtualStructure.getNext(scopeActual, tipoActual));
			VirtualStructure.reserveSpaces(scopeActual, tipoActual, r - 1);
			actualProcedure.increaseCounterByX(VirtualStructure.VariableType.Local, tipoActual, r);

			foreach(int dimension in dimensions)
			{
				r = r / dimension;
				vDim.Dimensions.Add(new Dimension(dimension, r));
			}

			actualProcedure.VariableTable.Add(t.val, vDim);

		}
  	.)
{COMA ID
	(.
			r = tam;
			Variable vDim = new Variable(t.val, tipoActual, VirtualStructure.getNext(scopeActual, tipoActual));
			VirtualStructure.reserveSpaces(scopeActual, tipoActual, r - 1);
			actualProcedure.increaseCounterByX(VirtualStructure.VariableType.Local, tipoActual, r);

			foreach(int dimension in dimensions)
			{
				r = r / dimension;
				vDim.Dimensions.Add(new Dimension(dimension, r));
			}

			actualProcedure.VariableTable.Add(t.val, vDim);
  	.)
}) PYC.


/*---------------------------------------------- FUNCION ---------------------------------------------- */
funcion = FUNCTION regresa
	(.
		//Se guarda el tipo de retorno de la funcion
		int retType = ReturnType.toReturnType(t.val);



		bool hasReturn = false;


	.)
ID 
	(.
		string functionName = t.val;
		int virtualDir = -1;
		//Se revise que la función no haya sido previamente declarada en el diccionario de procedimientos
		if (procedureTable.ContainsKey(t.val))
		{
			SemErr("Error - Funcion '" + t.val + "' previamente declarada");
		}
		else
		{
			//Si no, se añade a la tabla de procedimientos
			actualProcedure = new Procedure(t.val, retType);
			procedureTable.Add(t.val, actualProcedure);
			procedureList.Add(t.val);

			if (retType != ReturnType.Void)
			{
				//Se genera un dirección virtual para la función
				virtualDir = VirtualStructure.getNext(VirtualStructure.VariableType.Global, retType);

				//Se añade la función a la tabla de variables global
				procedureTable[programID].VariableTable.Add(functionName, new Variable(functionName, retType, virtualDir));

				//Se añade al tamaño de lo global
				procedureTable[programID].increaseCounter(VirtualStructure.VariableType.Local, retType);

			}



		}
		
	.) 
PARAB [parametro {COMA parametro }] PARCI LLAVEAB
(.
	//Se asigna la dirección inicial de la función
	actualProcedure.InitialDir = quadruples.Count;
.)
{vars} {estatuto} [ RETURN expresion 
	(.
		//Se saca el tipo de la expresion asi como el resultado
		int returnType = PTipos.Pop();
		int ret = PilaOperandos.Pop();

		if (ret == -1)
		{
			SemErr("Error - No se indexo la variable dimensionada.");
			finishExecution();
		}

		//Si el tipo de la expresión no coincide con el tipo de retorno se marca error
		if (returnType != retType)
		{
			SemErr("Error - Tipos incompatibles en return");
			finishExecution();
		}
		else
		{
			hasReturn = true;

			
			//Si si coincide se genera un nuevo cuádruplo
			insertQuadruple(OperationCode.Assignment, ret, -1, virtualDir);
		}

		

		

	.)
PYC ] LLAVECI 
	(.
		insertQuadruple(OperationCode.Ret, -1, -1, -1);


		//Si la función no es void y tiene return entonces hay error.
		if (retType != ReturnType.Void && !hasReturn)
		{
			SemErr("Error - Una función que no es void tiene que tener return.");
			finishExecution();
		}

		//Se resetean los contadores para que sean locales a cada función
		VirtualStructure.resetCounters();


	.)
.

/*---------------------------------------------- PARAMETRO ---------------------------------------------- */
parametro = [REF] tipo
	(.
		//Se saca el tipo de parametro y se añade a la lista de parametros de la función
		int type = DataType.toDataType(t.val);
		
	.)
(
 ID 
 	(.
 		//Si la variable ya estaba declarada se marca error
 		if (actualProcedure.VariableTable.ContainsKey(t.val))
		{
			SemErr("Variable previamente declarada");
		}
		else
		{
			//Si no, entonces se añade se la tabla de variables y se incrementa el contador de tamaño
			int virtDir = VirtualStructure.getNext(scopeActual, type);
			actualProcedure.VariableTable.Add(t.val, new Variable(t.val, type, virtDir));
			actualProcedure.Parameters.Add(new Parameter(type, virtDir));
			actualProcedure.increaseCounter(VirtualStructure.VariableType.Local, type);
		}
 	.)

| 
CORCHAB CTEENTERA
	(.
		List<int> dimensions = new List<int>();
		int dim = int.Parse(t.val);
		dimensions.Add(dim);
		int r = dim;
	.)
[ COMA CTEENTERA 
	(.
		dim = int.Parse(t.val);
		dimensions.Add(dim);
		r *= dim;
	.)
[ COMA CTEENTERA
	(.
		dim = int.Parse(t.val);
		dimensions.Add(dim);
		r *= dim;
	.)
] ] CORCHCI ID
	(.
		int tam = r;
  		//Si la variable dimensionada se encuentra en la tabla de variables se marca error
		if (actualProcedure.VariableTable.ContainsKey(t.val))
		{
			SemErr("Error - Variable '" + t.val + "' previamente declarada");
		}

		//Si no, entonces se añade a la tabla de variables
		else
		{
			Variable vDim = new Variable(t.val, tipoActual, VirtualStructure.getNext(scopeActual, tipoActual));
			VirtualStructure.reserveSpaces(scopeActual, tipoActual, r - 1);
			actualProcedure.increaseCounterByX(VirtualStructure.VariableType.Local, tipoActual, r);

			Parameter p = new Parameter(type, vDim.VirtualDir);
			p.Dimensions = vDim.Dimensions;
			actualProcedure.Parameters.Add(p);

			foreach(int dimension in dimensions)
			{
				r = r / dimension;
				vDim.Dimensions.Add(new Dimension(dimension, r));
			}

			actualProcedure.VariableTable.Add(t.val, vDim);

		}
	.)


) .

/*---------------------------------------------- MAIN ---------------------------------------------- */
main = VOID MAIN 
	(.



		//Se pone el main como procedimiento actual y se añade a la tabla de procedimientos
		actualProcedure = new Procedure("main", ReturnType.Main);
		procedureTable.Add("main", actualProcedure);
		procedureList.Add("main");

		//Se añade un nuevo cuadruplo "Era" con el numero de procedimiento
		insertQuadruple(OperationCode.Era, findProcedure("main"), 1, -1);


	.)
PARAB PARCI LLAVEAB 
	(.
		//Se asigna la dirección inicial al main 
		actualProcedure.InitialDir = quadruples.Count;
		//Se saca la posición del goto y se rellena con la dirección inicial
		int got = PSaltos.Pop();
		quadruples[got].TemporalRegorJump = quadruples.Count - 1;

	.)
{vars} {estatuto} LLAVECI
	(.
		VirtualStructure.resetCounters();
	.)
.

/*---------------------------------------------- REGRESA ---------------------------------------------- */
regresa = (tipo | VOID).

/*---------------------------------------------- TIPO ---------------------------------------------- */
tipo = (INT | FLOAT | STRING | BOOL | CHAR).

/*---------------------------------------------- BLOQUE ---------------------------------------------- */
bloque = LLAVEAB {estatuto} LLAVECI .

/*---------------------------------------------- CICLOWHILE ---------------------------------------------- */
ciclowhile = WHILE 
	(.
		//Se mete la posición antes de que se evalúe la expresión en la pila de saltos
		PSaltos.Push(quadruples.Count);
	.)
PARAB expresion 
	(.
		//Se saca el tipo de la expresión de la pila de tipos
		int aux = PTipos.Pop();

		//Si este no es booleano, entonces se marca error
		if (aux != DataType.Bool)
		{
			SemErr("Error - Se esperaba un booleano en el while");
			finishExecution();
		}
		else
		{
			//Si si es booleano entonces se saca el resultado de la expresión
			int res = PilaOperandos.Pop();

			if (res == -1)
			{
				SemErr("Error - No se indexo la variable dimensionada.");
				finishExecution();
			}
			//Se mete la posición del GotoF en la pila de Saltos
			PSaltos.Push(quadruples.Count);
			//Se genera el cuádruplo del GotoF con el resultado de la expresión
			insertQuadruple(OperationCode.GotoF, res, -1, -1);
			

		}
	.)
PARCI bloque
(.
	//Se saca la posición del GotoF y la posición antes de la expresión
	int falso = PSaltos.Pop();
	int retorno = PSaltos.Pop();

	//Se genera un nuevo cuádruplo Goto para regresar antes de la expresión y se añade a la lista de cuádruplos
	insertQuadruple(OperationCode.Goto, -1, -1, retorno);

	//Se rellena el cuadruplo del GotoF con la posición del siguiente cuádruplo
	quadruples[falso].TemporalRegorJump = quadruples.Count;

.)
.

/*---------------------------------------------- CICLOFOR ---------------------------------------------- */
ciclofor = FOR PARAB ID 
	(.
		//Se intenta insertar la variable en la pila de operandos
		tryToInsertVariable();
	.)
IGUAL 
	(.
		//Se mete a la pila de operadores el operador de asignación
		POper.Push(OperationCode.Assignment);
	.)
expresion
	(.
		//Se obtiene el lado derecho y el lado izquierdo de la expresión
		int ladoDer = PilaOperandos.Pop();
 		int ladoIzq = PilaOperandos.Pop();


 		if (ladoIzq == -1 || ladoDer == -1)
 		{
 			SemErr("Error - No se indexo la variable dimensionada.");
			finishExecution();
 		}

 		//Se obtiene el tipo resultante del lado izquierdo y del lado derecho, así como el operador
 		int tipoDer = PTipos.Pop();
 		int tipoIzq = PTipos.Pop();
 		int asigna = POper.Pop();

 		//Si si se puede asignar
 		if (tipoDer == tipoIzq)
 		{		
 			//Se genera un nuevo cuádruplo para realizar la asignación y se mete a la lista	
 			insertQuadruple(asigna, ladoDer, -1, ladoIzq);

 		}
 		else
 		{
 			//Si no, entonces hay un error de semántica
 			SemErr("Error - Tipos no compatibles en asignación.");
 		}

 		PSaltos.Push(quadruples.Count);		//Pointer a antes de condición

	.)
PYC expresion 
	(.
		int res = PilaOperandos.Pop();										//Resultado de evaluar la expresión del for
		int tipo = PTipos.Pop();											//Se obtiene el tipo resultante de la expresión

		if (res == -1)
		{
			SemErr("Error - No se indexo la variable dimensionada.");
			finishExecution();
		}

		//Se revisa que el tipo resultante sea booleano
		if (tipo != DataType.Bool)
		{
			//Si no lo es se marca error de semántica
			SemErr("Error - Se esperaba un booleano en el for");
			finishExecution();
		}
		else
		{
			PSaltos.Push(quadruples.Count);										//Pointer para regresar al GotoF
			insertQuadruple(OperationCode.GotoF, res, -1, -1);					//Genera cuadrupulo del GotoF
			PSaltos.Push(quadruples.Count);										//Pointer para regresar al Goto siguiente
			insertQuadruple(OperationCode.Goto, -1, -1, -1);					//Goto que sirve para saltar el incremento
			PSaltos.Push(quadruples.Count);										//Pointer a antes del incremento
		}

		
	.)
PYC expresion 
	(.
		int res2 = PilaOperandos.Pop();													//Resultado de lo que cambia la variable

		if (res2 == -1)
		{
			SemErr("Error - No se indexo la variable dimensionada.");
			finishExecution();
		}

		insertQuadruple(OperationCode.Assignment, res2, -1, ladoIzq);					//Se asigna el resultado de la expresion a la variable de control

		//Se sacan todos los datos que habiamos metido de la pila de saltos para crear el goto a antes de la condicion y rellenar el Goto que se saltaba la expresion de
		//la variable de control
		int antIncremento = PSaltos.Pop();										
		int saltoAEj = PSaltos.Pop();
		int gotoF = PSaltos.Pop();
		int antCondicion = PSaltos.Pop();

		insertQuadruple(OperationCode.Goto, -1, -1, antCondicion);


		quadruples[saltoAEj].TemporalRegorJump = quadruples.Count;

		//Se vuelven a meter los datos no usados al stack
		PSaltos.Push(gotoF);
		PSaltos.Push(antIncremento);

	.)
PARCI bloque
	(.
		//Se saca el antes del incremento para crear un goto vaya hacia las operaciones para la variable de control
		antIncremento = PSaltos.Pop();
		insertQuadruple(OperationCode.Goto, -1, -1, antIncremento);

		//Se rellena el GotoF hacia la siguiente instrucción a ejecutar
		gotoF = PSaltos.Pop();
		quadruples[gotoF].TemporalRegorJump = quadruples.Count;

	.)
.

/*---------------------------------------------- CICLOS ---------------------------------------------- */
ciclos = (ciclowhile | ciclofor).

/*---------------------------------------------- CONDICION ---------------------------------------------- */
condicion = IFF PARAB expresion 
	(.
		//Se obtiene el tipo resultante de la expresión de la pila de tipos
		int aux = PTipos.Pop();

		//Se revisa que este tipo sea booleano
		if (aux != DataType.Bool)
		{
			//Si no lo es, se genera error
			SemErr("Error - Se esperaba un booleano en el if");
			finishExecution();
		}
		else
		{
			//Si si es, entonces se saca el resultado de la expresión 
			int res = PilaOperandos.Pop();

			if (res == -1)
			{
				SemErr("Error - No se indexo la variable dimensionada.");
				finishExecution();
			}

			//Se añade a la pila de saltos la posición del GotoF
			PSaltos.Push(quadruples.Count);
			//Se genera y añade a la lista un nuevo cuádruplo GotoF con el resultado
			insertQuadruple(OperationCode.GotoF, res, -1, -1);



		}
	.)
PARCI bloque [ELSE  
	(.
		//Se crea un nuevo cuádruplo Goto para saltarse el else
		insertQuadruple(OperationCode.Goto, -1, -1, -1);

		//Se obtiene la posición del GotoF y se rellena con la siguiente posición de la lista
		int falso = PSaltos.Pop();
		quadruples[falso].TemporalRegorJump = quadruples.Count;

		//Se mete a la pila de saltos la posición del Goto 
		PSaltos.Push(quadruples.Count - 1);

	.)
bloque]
	(.
		//Se saca la posición del Goto y se rellena con la siguiente posición en la lista
		int fin = PSaltos.Pop();
		quadruples[fin].TemporalRegorJump = quadruples.Count;
	.)
.

/*---------------------------------------------- ESTATUTO ---------------------------------------------- */
estatuto = (condicion | escritura | ciclos | asignacionollamada ). 

/*---------------------------------------------- LECTURA ---------------------------------------------- */
lectura = READLINE 
	(.
		//Se obtiene la siguiente dirección virtual para los temporales y se mete a la pila de operandos
		int tempString = VirtualStructure.getNext(VirtualStructure.VariableType.Temporal, DataType.String);
		PilaOperandos.Push(tempString);
		//Se mete un cero la pila de tipos ya que la lectura puede ser de cualquier tipo
		PTipos.Push(0);

		//Se genera un nuevo cuádruplo con el Readline y el tempString
		Quadruple qAux = new Quadruple(OperationCode.ReadLine, -1, -1, tempString);
	.)
PARAB PARCI.

/*---------------------------------------------- ESCRITURA ---------------------------------------------- */
escritura = PRINT PARAB expresion
	(.
		//Se saca el resultado de evaluar la expresión y con eso se genera un cuádruplo para imprimirlo
		int resExp = PilaOperandos.Pop();

		if (resExp == -1)
		{
			SemErr("Error - No se indexo la variable dimensionada.");
			finishExecution();
		}

		insertQuadruple(OperationCode.Print, -1, -1, resExp);
	.)

 { COMA expresion
	(.
		//Se saca el resultado de evaluar la expresión y con eso se genera un cuádruplo para imprimirlo
		resExp = PilaOperandos.Pop();

		if (resExp == -1)
		{
			SemErr("Error - No se indexo la variable dimensionada.");
			finishExecution();
		}

		insertQuadruple(OperationCode.Print, -1, -1, resExp);
	.)
  } PARCI PYC.

/*---------------------------------------------- ASIGNACIONOLLAMADA ---------------------------------------------- */
asignacionollamada = ID
	(.
		string id = t.val; //Se guarda el id por si es una función
	.)
(
	(.
		//Se intenta insertar la variable a asignar en la pila de operandos
		tryToInsertVariable();
	.)
[
	(.
		PilaOperandos.Pop();
		PTipos.Pop();
	.)

cuantificador] IGUAL
	(.
		//Se mete el operador de igual a la pila de operadores
		POper.Push(OperationCode.Assignment);
	.)
 (expresion | lectura) 
(.
		//Se saca el lado derecho y el lado izquierdo de la asignación
 		int ladoDer = PilaOperandos.Pop();
 		int ladoIzq = PilaOperandos.Pop();

 		if (ladoDer == -1 || ladoIzq == -1)
 		{
			SemErr("Error - No se indexo la variable dimensionada.");
			finishExecution();
 		}

 		//Se saca el tipo del lado derecho y el tipo de lado izquierdo de la asignación
 		int tipoDer = PTipos.Pop();
 		int tipoIzq = PTipos.Pop();
 		int asigna = POper.Pop();

 		//Si lo tipos son iguales o acepta cualquier tipo
 		if (tipoDer == tipoIzq || tipoDer == 0)
 		{	
 			//Se genera un nuevo cuádruplo y se mete a la lista		
 			insertQuadruple(asigna, ladoDer, -1, ladoIzq);
 		}
 		else
 		{
 			//Si no, se genera un error de semántica
 			SemErr("Error - Tipos no compatibles en asignación.");
 			finishExecution();
 		}	
.)
 | PARAB 
	(.
		//Si el procedimiento no se encuentra en el diccionario de procedimientos
		if (!procedureTable.ContainsKey(id))
		{
			//Se marca error de semántica
			SemErr("Error - La función que se intenta llamar no existe.");
			finishExecution();
		}
		else
		{
			if (procedureTable[id].Type != 0)
			{
				SemErr("Error - La llamada a la función tiene que ser void");
			}
			else
			{
				//Se añade un nuevo cuadruplo "Era" con el numero de procedimiento
				insertQuadruple(OperationCode.Era, findProcedure(id), -1, -1);
			}
			
		}

		int k = 0; 					//Se inicializa el apuntador a parametros


	.)
 [expresion 
	(.
		tryToInsertArgument(k, id);
	.)
 {COMA 
	(.
		k++;
	.)
 expresion 
 	(.
 		tryToInsertArgument(k, id);
	.)

 }] PARCI
	(.
		if (k + 1 < procedureTable[id].Parameters.Count)
		{
			SemErr("Error - El numero de parametros no coindice con la declaración de la función");
		}

		insertQuadruple(OperationCode.GoSub, findProcedure(id), -1, procedureTable[id].InitialDir);
	.)

 ) PYC.

/*---------------------------------------------- CUANTIFICADOR ---------------------------------------------- */
cuantificador = 
(.
	string id = t.val;
	int dim = 0;
	Dimension d = null;

	Variable vDim = tryToInsertVariable();
	
	int dirBase = PilaOperandos.Pop();
	int tipo = PTipos.Pop();

	if (vDim.Dimensions.Count == 0)
	{
		SemErr("Error - La variable que se intenta accesar no es dimensionada");
		finishExecution();
	}
	else
	{
		dim = 0;
		d = vDim.Dimensions[dim];
		POper.Push(-1);
	}
	
.)
CORCHAB expresion
	(.
		processDimension(dim, d, vDim);
	.)
[COMA
	(.
		

		dim++;

		if (dim + 1 > vDim.Dimensions.Count)
		{
			SemErr("Error - El número de dimensiones no coincide con lo declarado.");
			finishExecution();
		}

		d = vDim.Dimensions[dim];
	.) 
expresion
	(.
		processDimension(dim, d, vDim);
	.)
[COMA 
	(.
		dim++;

		if (dim + 1 > vDim.Dimensions.Count)
		{
			SemErr("Error - El número de dimensiones no coincide con lo declarado.");
			finishExecution();
		}

		d = vDim.Dimensions[dim];
	.) 
expresion
	(.
		processDimension(dim, d, vDim);
	.)
] ] CORCHCI
	(.

		if (dim + 1 != vDim.Dimensions.Count)
		{
			SemErr("Error - El número de dimensiones no coincide con lo declarado.");
			finishExecution();
		}

		int aux1 = PilaOperandos.Pop();
		int tAux1 = PTipos.Pop();


		int vTemp3 = VirtualStructure.getNext(VirtualStructure.VariableType.Temporal, DataType.Int);
		actualProcedure.increaseCounter(VirtualStructure.VariableType.Temporal, DataType.Int);


		tryToInsertConstant(DataType.Int, vDim.VirtualDir.ToString());

		int vDir = PilaOperandos.Pop();
		PTipos.Pop();

		insertQuadruple(OperationCode.Sum, aux1, vDir, vTemp3);
		PTipos.Push(vDim.Type);

		PilaOperandos.Push(-vTemp3);

		POper.Pop();
	.)
.


/*---------------------------------------------- EXPRESION ---------------------------------------------- */
expresion = comparacion
	(.
		//Si en el tope de la pila de operadores hay un and o un or
		if (POper.Count > 0 && (POper.Peek() == OperationCode.And || POper.Peek() == OperationCode.Or))
		{
			//Se resuelve generando un cuadruplo
			tryToGenerateQuadruple();
		}
	.)
{(AND | OR) 
	(.
		//Se mete el and o el or en la pila de operadores
		POper.Push(OperationCode.toOperationCode(t.val));
	.)
comparacion
	(.
		//Si en el tope de la pila de operadores hay un and o un or
		if (POper.Count > 0 && (POper.Peek() == OperationCode.And || POper.Peek() == OperationCode.Or))
		{
			//Se resuelve generando un cuadruplo
			tryToGenerateQuadruple();
		}
	.)
}.

/*---------------------------------------------- COMPARACION ---------------------------------------------- */
comparacion = exp [(MAQUE | MEQUE | MAQUEEQ | MEQUEEQ | DIFERENTE | COMPARACION) 
	(.
		//Se mete el < o > o != o == a la pila de operadores
		POper.Push(OperationCode.toOperationCode(t.val));
	.)
exp
	(.
		//Si en el tope de la pila de operadores hay un < o > o != o ==
		if (POper.Count > 0 && (POper.Peek() == OperationCode.MoreThan || POper.Peek() == OperationCode.LessThan || POper.Peek() == OperationCode.MoreThanEq || POper.Peek() == OperationCode.LessThanEq || POper.Peek() == OperationCode.Different || POper.Peek() == OperationCode.EqualComparison))
		{
			//Se resuelve generando un cuadruplo
			tryToGenerateQuadruple();
		}
	.)
].

/*---------------------------------------------- EXP ---------------------------------------------- */
exp = term
	(.
		//Si en el tope de la pila de operadores hay una suma o resta
		if (POper.Count > 0 && (POper.Peek() == OperationCode.Sum || POper.Peek() == OperationCode.Substraction))
		{
			//Se resuelve generando un cuadruplo
			tryToGenerateQuadruple();
		}
	.)

 {(MAS | MENOS) 
	(.
		//Se mete la suma o la rest a la pila de operadores
		POper.Push(OperationCode.toOperationCode(t.val));
	.)	
	term
	(.
		//Si en el tope de la pila de operadores hay una suma o resta
		if (POper.Count > 0 && (POper.Peek() == OperationCode.Sum || POper.Peek() == OperationCode.Substraction))
		{
			//Se resuelve generando un cuadruplo
			tryToGenerateQuadruple();
		}
	.)
	}.

/*---------------------------------------------- TERM ---------------------------------------------- */
term = factor
	(.
		//Si en el tope de la pila de operadores hay una multiplicación o división
		if (POper.Count > 0 && (POper.Peek() == OperationCode.Multiplication || POper.Peek() == OperationCode.Division))
		{
			//Se resuelve generando un cuadruplo
			tryToGenerateQuadruple();
		}
	.)
{(MULT | DIV) 
	(.
		//Se mete la multiplicación o división a la pila de operadores
		POper.Push(OperationCode.toOperationCode(t.val));
	.)
factor
	(.
		//Si en el tope de la pila de operadores hay una multiplicación o división
		if (POper.Count > 0 && (POper.Peek() == OperationCode.Multiplication || POper.Peek() == OperationCode.Division))
		{
			//Se resuelve generando un cuadruplo
			tryToGenerateQuadruple();
		}
	.)

}.

/*---------------------------------------------- FACTOR ---------------------------------------------- */
factor = PARAB
	(.
		//Se mete un fondo falso
		POper.Push(-1);
	.)
 expresion PARCI
 	(.
 		//Se saca el fondo falso
 		POper.Pop();
	.)
  | [MAS | MENOS] ctevar.

/*---------------------------------------------- CTEVAR ---------------------------------------------- */
ctevar = (ctelet | ctebool | ctenum | ID
	(.
		//Se obtiene el id 
		string id = t.val;
	.)
 (PARAB
	(.

		POper.Push(-1);

		//Si el procedimiento no se encuentra en el diccionario de procedimientos
		if (!procedureTable.ContainsKey(id))
		{
			//Se marca error de semántica
			SemErr("Error - La función que se intenta llamar no existe.");
			finishExecution();
		}
		else
		{
			if (procedureTable[id].Type == ReturnType.Void || procedureTable[id].Type == ReturnType.Program || procedureTable[id].Type == ReturnType.Main)
			{
				SemErr("Error - La función tiene que regresar algo para usarse como expresión.");
			}
			else
			{
				//Se añade un nuevo cuadruplo "Era" con el numero de procedimiento
				insertQuadruple(OperationCode.Era, findProcedure(id), -1, -1);
			}
			
		}

		int k = 0; 					//Se inicializa el apuntador a parametros
	.)

 [expresion
	(.
		tryToInsertArgument(k, id);
	.)
 {COMA
	(.
		k++;
	.)
 expresion
	(.
		tryToInsertArgument(k, id);
	.)
 }] PARCI
 	(.
 		if (k + 1 < procedureTable[id].Parameters.Count)
		{
			SemErr("Error - El numero de parametros no coindice con la declaración de la función");
		}
 		insertQuadruple(OperationCode.GoSub, findProcedure(id), -1, procedureTable[id].InitialDir);

 		Variable funcVariable = procedureTable[programID].VariableTable[id];
 		
 		int temporal = VirtualStructure.getNext(VirtualStructure.VariableType.Temporal, funcVariable.Type);
 		actualProcedure.increaseCounter(VirtualStructure.VariableType.Temporal, funcVariable.Type);

 		PilaOperandos.Push(temporal);
 		PTipos.Push(funcVariable.Type);
 		insertQuadruple(OperationCode.Assignment, funcVariable.VirtualDir, -1, temporal);

 		POper.Pop();


 	.)
 | cuantificador |
	(.
		//Intenta insertar la variable en la pila de operandos
		tryToInsertVariable();
	.)
 ) ).

/*---------------------------------------------- CTELET ---------------------------------------------- */
ctelet = (CTESTRING
	(.
		//Se intenta insertar la constante string al diccionario de constantes 
		tryToInsertConstant(DataType.String, t.val.Replace("\"", "").Replace(@"\n", "\n"));
	.)
 | CTECHAR
	(.
		//Se intenta insertar la constante char al diccionario de constantes 
		tryToInsertConstant(DataType.Char, t.val);
	.)
 ).

/*---------------------------------------------- CTEBOOL ---------------------------------------------- */
ctebool = (TRUE | FALSE) 
	(.
		//Se intenta insertar la constante bool al diccionario de constantes 
		tryToInsertConstant(DataType.Bool, t.val);
	.)
.

/*---------------------------------------------- CTENUM ---------------------------------------------- */
ctenum = (CTEENTERA 
	(.
		//Se intenta insertar la constante entera al diccionario de constantes 
		tryToInsertConstant(DataType.Int, t.val);
	.)
| CTEFLOAT
	(.
		//Se intenta insertar la constante flotante al diccionario de constantes 
		tryToInsertConstant(DataType.Float, t.val);
	.)
).


/*------------------------------------------------------------------------*/


END PLearning.
