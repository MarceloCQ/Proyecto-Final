using PLearning_Backend.Model;
using System.Collections.Generic;
using PLearning_Backend.Enumerations;
using PLearning_Backend.Structures;

COMPILER PLearning
 
	Dictionary<string, Procedure> procedureTable;
	Procedure actualProcedure;
	int tipoActual;
	int scopeActual = VirtualStructure.VariableType.Global;
	string programID;

	Stack<int> POper = new Stack<int>();
	Stack<int> PilaOperandos = new Stack<int>();
	Stack<int> PTipos = new Stack<int>();

	List<Quadruple> quadruples = new List<Quadruple>();

	private void tryToGenerateQuadruple()
	{
		int operat = POper.Pop();
		int operand2 = PilaOperandos.Pop();
		int tipo2 = PTipos.Pop();
		int operand1 = PilaOperandos.Pop();
		int tipo1 = PTipos.Pop();

		int newType = SemanticCube.getCombiningType(tipo1, tipo2, operat);

		if (newType != 0)
		{
			int temp = VirtualStructure.getNext(VirtualStructure.VariableType.Temporal, newType);				 
			Quadruple qAux = new Quadruple(operat, operand1, operand2, temp);
			quadruples.Add(qAux);
			PilaOperandos.Push(temp);
			PTipos.Push(newType);
		}
		else
		{
			SemErr("Error - Tipos incompatibles");
			finishExecution();
		}
	}

	private void tryToInsertVariable()
	{
		if (!actualProcedure.VariableTable.ContainsKey(t.val))
		{
			if (!procedureTable[programID].VariableTable.ContainsKey(t.val))
			{
				SemErr("Variable no declarada");
			}
			else
			{
				Variable v = procedureTable[programID].VariableTable[t.val];
				PilaOperandos.Push(v.VirtualDir);
				PTipos.Push(v.Type);
			}
			
		}
		else
		{
			Variable v = actualProcedure.VariableTable[t.val];
			PilaOperandos.Push(v.VirtualDir);
			PTipos.Push(v.Type);
		}
	}

	private void finishExecution()
	{
		Console.ReadLine();
		Environment.Exit(1);
	}


/*--------------------------------------------------------------------------*/
CHARACTERS
	letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
	digit = "0123456789".
	eol                = '\u000a'. /* 10 = line feed */
	cr  = '\r'.
	newLine = cr + eol. 
	char = ANY - "'" - '\\' - newLine.
	lf  = '\n'.
	tab = '\t'.

TOKENS
	ID = letter { letter | digit }.
	CTEENTERA = digit {digit}.
	CTEFLOAT = digit {digit} "." digit {digit}.
	CTESTRING = '"' letter { letter | digit } '"'.
	CTECHAR = '\'' char '\''.
	PROGRAM  = "program".
	MAIN = "main".
	VOID = "void".
	INT = "int".
	FLOAT = "float".
	STRING = "string".
	BOOL = "bool".
	CHAR = "char".
	IFF = "if".
	ELSE = "else".
	AND = "and".
	OR = "or".
	WHILE = "while".
	FOR = "for".
	RETURN = "return".
	PRINT = "print".
	READLINE = "readLine".
	FUNCTION = "function".
	TRUE = "true".
	FALSE = "false".
	REF = "ref".
	PYC = ";".
	COMA = ",".
	IGUAL = "=".
	PARAB = "(".
	PARCI = ")".
	LLAVEAB = "{".
	LLAVECI = "}".
	CORCHAB = "[".
	CORCHCI = "]".
	MAS = "+".
	MENOS = "-".
	MULT = "*".
	DIV = "/".
	MAQUE = ">".
	MEQUE = "<".
	DIFERENTE = "!=".
	COMPARACION = "==".


IGNORE cr + lf + tab



PRODUCTIONS
/*------------------------------------------------------------------------*/
/*---------------------------------------------- PLEARNING ---------------------------------------------- */
PLearning = PROGRAM
	(. 
		procedureTable = new Dictionary<string, Procedure>(); 
	.)
 ID
 	(. 
 		actualProcedure = new Procedure(t.val, ReturnType.Program);
 		procedureTable.Add(t.val, actualProcedure);   
 		programID = t.val;
	.) 
PYC {vars}
	(.
		scopeActual = VirtualStructure.VariableType.Local; 
	.)
 {funcion} main.

/*---------------------------------------------- VARS ---------------------------------------------- */
vars = tipo
	(. 
 		tipoActual = DataType.toDataType(t.val); 
 	.)
(ID 
	(.
		if (actualProcedure.VariableTable.ContainsKey(t.val))
		{
			SemErr("Error - Variable " + t.val + " previamente declarada");
		}
		else
		{
			actualProcedure.VariableTable.Add(t.val, new Variable(t.val, tipoActual, VirtualStructure.getNext(scopeActual, tipoActual)));
		}
  	.)
{COMA ID
 	(.
 		if (actualProcedure.VariableTable.ContainsKey(t.val))
		{
			SemErr("Error - Variable '" + t.val + "' previamente declarada");
		}
		else
		{
			actualProcedure.VariableTable.Add(t.val, new Variable(t.val, tipoActual, VirtualStructure.getNext(scopeActual, tipoActual)));
		} 
	.)
 } [IGUAL (ctelet | ctenum | ctebool)] PYC | CORCHAB CTEENTERA [ COMA CTEENTERA ] CORCHCI 
 ID
  (.
		if (actualProcedure.VariableTable.ContainsKey(t.val))
		{
			SemErr("Error - Variable '" + t.val + "' previamente declarada");
		}
		else
		{
			actualProcedure.VariableTable.Add(t.val, new Variable(t.val, tipoActual, VirtualStructure.getNext(scopeActual, tipoActual)));
		}
  	.)
{COMA ID
	(.
		if (actualProcedure.VariableTable.ContainsKey(t.val))
		{
			SemErr("Error - Variable '" + t.val + "' previamente declarada");
		}
		else
		{
			actualProcedure.VariableTable.Add(t.val, new Variable(t.val, tipoActual, VirtualStructure.getNext(scopeActual, tipoActual)));
		}
  	.)
} PYC ).


/*---------------------------------------------- FUNCION ---------------------------------------------- */
funcion = FUNCTION regresa
	(.
		int retType = ReturnType.toReturnType(t.val);
	.)
ID 
	(.
		if (procedureTable.ContainsKey(t.val))
		{
			SemErr("Error - Funcion '" + t.val + "' previamente declarada");
		}
		else
		{
			actualProcedure = new Procedure(t.val, retType);
			procedureTable.Add(t.val, actualProcedure);
		}
		
	.) 
PARAB [parametro {COMA parametro }] PARCI LLAVEAB {vars} {estatuto} [ RETURN expresion PYC ] LLAVECI .

/*---------------------------------------------- MAIN ---------------------------------------------- */
main = VOID MAIN 
	(.
		actualProcedure = new Procedure("main", ReturnType.Main);
		procedureTable.Add("main", actualProcedure);
	.)
PARAB PARCI LLAVEAB {vars} {estatuto} LLAVECI .

/*---------------------------------------------- REGRESA ---------------------------------------------- */
regresa = (tipo | VOID).

/*---------------------------------------------- TIPO ---------------------------------------------- */
tipo = (INT | FLOAT | STRING | BOOL | CHAR).

/*---------------------------------------------- BLOQUE ---------------------------------------------- */
bloque = LLAVEAB {estatuto} LLAVECI .

/*---------------------------------------------- CICLOWHILE ---------------------------------------------- */
ciclowhile = WHILE PARAB expresion PARCI bloque.

/*---------------------------------------------- CICLOFOR ---------------------------------------------- */
ciclofor = FOR PARAB ID IGUAL expresion PYC expresion PYC expresion PARCI bloque.

/*---------------------------------------------- CICLOS ---------------------------------------------- */
ciclos = (ciclowhile | ciclofor).

/*---------------------------------------------- CONDICION ---------------------------------------------- */
condicion = IFF PARAB expresion PARCI bloque [ELSE  bloque].

/*---------------------------------------------- ESTATUTO ---------------------------------------------- */
estatuto = (condicion | escritura | ciclos | asignacionollamada ). 

/*---------------------------------------------- LECTURA ---------------------------------------------- */
lectura = READLINE 
	(.
		int tempString = VirtualStructure.getNext(VirtualStructure.VariableType.Temporal, DataType.String);
		PilaOperandos.Push(tempString);
		PTipos.Push(DataType.String);
		Quadruple qAux = new Quadruple(OperationCode.ReadLine, -1, -1, tempString);
	.)
PARAB PARCI.

/*---------------------------------------------- ESCRITURA ---------------------------------------------- */
escritura = PRINT PARAB expresion
	(.
		int resExp = PilaOperandos.Pop();
		Quadruple qAux = new Quadruple(OperationCode.Print, -1, -1, resExp);
		quadruples.Add(qAux);
	.)

 { COMA expresion
	(.
		resExp = PilaOperandos.Pop();
		qAux = new Quadruple(OperationCode.Print, -1, -1, resExp);
		quadruples.Add(qAux);
	.)
  } PARCI PYC.

/*---------------------------------------------- ASIGNACIONOLLAMADA ---------------------------------------------- */
asignacionollamada = ID (
	(.
		tryToInsertVariable();
	.)
[cuantificador] IGUAL
	(.
		POper.Push(OperationCode.Assignment);
	.)
 (expresion | lectura) 
(.
 		int ladoDer = PilaOperandos.Pop();
 		int ladoIzq = PilaOperandos.Pop();

 		int tipoDer = PTipos.Pop();
 		int tipoIzq = PTipos.Pop();
 		int asigna = POper.Pop();

 		if (tipoDer == tipoIzq)
 		{			
 			Quadruple qAux = new Quadruple(asigna, ladoDer, -1, ladoIzq);
 			quadruples.Add(qAux);
 		}
 		else
 		{
 			SemErr("Error - Tipos no compatibles en asignaciÃ³n.");
 		}	
.)
 | PARAB [expresion {COMA expresion }] PARCI) PYC.

/*---------------------------------------------- CUANTIFICADOR ---------------------------------------------- */
cuantificador = CORCHAB expresion [COMA expresion ] CORCHCI.

/*---------------------------------------------- PARAMETRO ---------------------------------------------- */
parametro = [REF] tipo
	(.
		int type = DataType.toDataType(t.val);
	.)
 ID 
 	(.
 		if (actualProcedure.VariableTable.ContainsKey(t.val))
		{
			SemErr("Variable previamente declarada");
		}
		else
		{
			actualProcedure.VariableTable.Add(t.val, new Variable(t.val, type, VirtualStructure.getNext(scopeActual, type)));
		}
 	.)

 [ CORCHAB CORCHCI ].

/*---------------------------------------------- EXPRESION ---------------------------------------------- */
expresion = comparacion
	(.
		if (POper.Count > 0 && (POper.Peek() == OperationCode.And || POper.Peek() == OperationCode.Or))
		{
			tryToGenerateQuadruple();
		}
	.)
{(AND | OR) 
	(.
		POper.Push(OperationCode.toOperationCode(t.val));
	.)
comparacion
	(.
		if (POper.Count > 0 && (POper.Peek() == OperationCode.And || POper.Peek() == OperationCode.Or))
		{
			tryToGenerateQuadruple();
		}
	.)
}.

/*---------------------------------------------- COMPARACION ---------------------------------------------- */
comparacion = exp [(MAQUE | MEQUE | DIFERENTE | COMPARACION) 
	(.
		POper.Push(OperationCode.toOperationCode(t.val));
	.)
exp
	(.
		if (POper.Count > 0 && (POper.Peek() == OperationCode.MoreThan || POper.Peek() == OperationCode.LessThan || POper.Peek() == OperationCode.Different || POper.Peek() == OperationCode.EqualComparison))
		{
			tryToGenerateQuadruple();
		}
	.)
].

/*---------------------------------------------- EXP ---------------------------------------------- */
exp = term
	(.
		if (POper.Count > 0 && (POper.Peek() == OperationCode.Sum || POper.Peek() == OperationCode.Substraction))
		{
			tryToGenerateQuadruple();
		}
	.)

 {(MAS | MENOS) 
	(.
		POper.Push(OperationCode.toOperationCode(t.val));
	.)	
	term
	(.
		if (POper.Count > 0 && (POper.Peek() == OperationCode.Sum || POper.Peek() == OperationCode.Substraction))
		{
			tryToGenerateQuadruple();
		}
	.)
	}.

/*---------------------------------------------- TERM ---------------------------------------------- */
term = factor
	(.
		if (POper.Count > 0 && (POper.Peek() == OperationCode.Multiplication || POper.Peek() == OperationCode.Division))
		{
			tryToGenerateQuadruple();
		}
	.)
{(MULT | DIV) 
	(.
		POper.Push(OperationCode.toOperationCode(t.val));
	.)
factor
	(.
		if (POper.Count > 0 && (POper.Peek() == OperationCode.Multiplication || POper.Peek() == OperationCode.Division))
		{
			tryToGenerateQuadruple();
		}
	.)

}.

/*---------------------------------------------- FACTOR ---------------------------------------------- */
factor = PARAB
	(.
		POper.Push(-1);
	.)
 expresion PARCI
 	(.
 		POper.Pop();
	.)
  | [MAS | MENOS] ctevar.

/*---------------------------------------------- CTEVAR ---------------------------------------------- */
ctevar = (ctelet | ctebool | ctenum | ID
	(.
		string id = t.val;
	.)
 (PARAB [expresion {COMA expresion }] PARCI | cuantificador |
	(.
		tryToInsertVariable();
	.)
 ) ).

/*---------------------------------------------- CTELET ---------------------------------------------- */
ctelet = (CTESTRING
	(.
		int virtualDir = VirtualStructure.getNext(VirtualStructure.VariableType.Constant, DataType.String);
		PilaOperandos.Push(virtualDir);
		PTipos.Push(DataType.String);
	.)
 | CTECHAR
	(.
		int virtualDir = VirtualStructure.getNext(VirtualStructure.VariableType.Constant, DataType.Char);
		PilaOperandos.Push(virtualDir);
		PTipos.Push(DataType.Char);
	.)
 ).

/*---------------------------------------------- CTEBOOL ---------------------------------------------- */
ctebool = (TRUE | FALSE) 
	(.
		int virtualDir = VirtualStructure.getNext(VirtualStructure.VariableType.Constant, DataType.Bool);
		PilaOperandos.Push(virtualDir);
		PTipos.Push(DataType.Bool);
	.)
.

/*---------------------------------------------- CTENUM ---------------------------------------------- */
ctenum = (CTEENTERA 
	(.
		int virtualDir = VirtualStructure.getNext(VirtualStructure.VariableType.Constant, DataType.Int);
		PilaOperandos.Push(virtualDir);
		PTipos.Push(DataType.Int);
	.)
| CTEFLOAT
	(.
		int virtualDir = VirtualStructure.getNext(VirtualStructure.VariableType.Constant, DataType.Float);
		PilaOperandos.Push(virtualDir);
		PTipos.Push(DataType.Float);
	.)
).


/*------------------------------------------------------------------------*/


END PLearning.
