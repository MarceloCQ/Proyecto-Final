using PLearning_Backend.Model;
using System.Collections.Generic;
using PLearning_Backend.Enumerations;
using PLearning_Backend.Structures;

COMPILER PLearning
 
	Dictionary<string, Procedure> procedureTable;			//Diccionario de procedimientos, la llave es el nombre del procedimiento
	Dictionary<string, Constant> constantTable;				//Diccionario de constantes, la llave es el valor de la constante

	Procedure actualProcedure;								//Apunta al procedimiento actual en el que se está
	int tipoActual;
	int scopeActual = VirtualStructure.VariableType.Global;	//Apunta al scope actual, global o local
	string programID;										//Nombre del programa

	Stack<int> POper = new Stack<int>();					//Pila de operadores para la generación de cuadruplos
	Stack<int> PilaOperandos = new Stack<int>();			//Pila de operandos para la generación de cuádruplos
	Stack<int> PTipos = new Stack<int>();					//Pila de tipos para la validación de semántica
	Stack<int> PSaltos = new Stack<int>();					//Pila de saltos para guardar los Jumps o la referencia a un Goto/GotoF

	List<Quadruple> quadruples = new List<Quadruple>();		//Lista de los cuádruplos del programa

	/// <summary>
    /// Método que sirve para intentar generar un cuádruplo de las expresiones, revisa que se
    /// pueda realizar la operación y si no, manda un error de semántica. 
    /// </summary>
	private void tryToGenerateQuadruple()
	{
		int operat = POper.Pop();				//Se saca el operador de la pila de operadores
		int operand2 = PilaOperandos.Pop();		//Se saca el operando del lado derecho de la pila de operandos
		int tipo2 = PTipos.Pop();				//Se saca el tipo del operando del lado derecho de la pila de tipos
		int operand1 = PilaOperandos.Pop();		//Se saca el operando del lado izquierdo de la pila de operandos
		int tipo1 = PTipos.Pop();				//Se saca el tipo del operando del lado izquierdo de la pila de tipos

		//Se obtiene el tipo resultante del cubo semántico al combinar ambos tipos con el operador
		int newType = SemanticCube.getCombiningType(tipo1, tipo2, operat);  

		//Se verifica que el tipo resultante no sea cero, es decir, que si se puedan combinar dichos tipos
		if (newType != 0)
		{
			int temp = VirtualStructure.getNext(VirtualStructure.VariableType.Temporal, newType); 	//Se obtiene la siguiente dirección temporal
			actualProcedure.increaseCounter(VirtualStructure.VariableType.Temporal, newType);	  	//Se incrementa el contador de tamaño de temporales					 	
			Quadruple qAux = new Quadruple(operat, operand1, operand2, temp);						//Se genera un nuevo cuadruplo con los datos obtenidos		
			quadruples.Add(qAux);																	//Se añade a la lista de cuádruplos
			PilaOperandos.Push(temp);																//Se mete el temporal resultante a la pila de operandos
			PTipos.Push(newType);																	//Se mete el tipo resultante a a la pila de tipos
		}
		//Si no se pueden combinar
		else
		{
			//Se genera un error de semántica y se termina la ejecución
			SemErr("Error - Tipos incompatibles");
			finishExecution();
		}
	}

	/// <summary>
    /// Método que sirve para intentar insertar una variable en la pila de operandos 
    /// </summary>
	private void tryToInsertVariable()
	{
		//Si la variable no está en la tabla de variables del procedimiento correspondiente
		if (!actualProcedure.VariableTable.ContainsKey(t.val))
		{
			//Si la varaible no está en la tabla de variables del procedimiento global
			if (!procedureTable[programID].VariableTable.ContainsKey(t.val))
			{
				//Se genera un error de semántica
				SemErr("Variable no declarada");
				finishExecution();
			}
			//Si la variable se encuentra en la tabla de variables del procedimiento global
			else
			{
				//Se mete la dirección en la pila de operandos y el tipo en la pila de tipos.
				Variable v = procedureTable[programID].VariableTable[t.val];
				PilaOperandos.Push(v.VirtualDir);
				PTipos.Push(v.Type);
			}
			
		}
		//Si la variable si se encuentra en la tabla de variables del procedimiento actual
		else
		{
			//Se mete la dirección en la pila de operandos y el tipo en la pila de tipos.
			Variable v = actualProcedure.VariableTable[t.val];
			PilaOperandos.Push(v.VirtualDir);
			PTipos.Push(v.Type);
		}
	}

	/// <summary>
    /// Método que sirve para intentar insertar una constante en la pila de operandos 
    /// </summary>
	private void tryToInsertConstant(int dataType)
	{
		int virtualDir;							//Direccion virtual de la constante

		//Si la constante ya se encuentra en el diccionario
		if (constantTable.ContainsKey(t.val))
		{	
			//Se obtiene la dirección virtual
			virtualDir = constantTable[t.val].VirtualDir;
		}
		//Si no se encuentra en el diccionario
		else
		{
			//Se obtiene la dirección virtual de la estructura virtual
			virtualDir = VirtualStructure.getNext(VirtualStructure.VariableType.Constant, dataType);

			//Se crea la nueva constante
			Constant c = new Constant(t.val, virtualDir);

			//Se inserta en la tabla de constantes
			constantTable.Add(t.val, c);
		}
		
		//Se inserta la constante en la pila de operandos y en la pila de tipos
		PilaOperandos.Push(virtualDir);
		PTipos.Push(dataType);
	}

	///<summary>
	/// Método que sirve para finalizar la ejecución del programa.
	///</summary>
	private void finishExecution()
	{
		Console.ReadLine();
		Environment.Exit(1);
	}


/*--------------------------------------------------------------------------*/
CHARACTERS
	letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
	digit = "0123456789".
	eol                = '\u000a'. /* 10 = line feed */
	cr  = '\r'.
	newLine = cr + eol. 
	char = ANY - "'" - '\\' - newLine.
	lf  = '\n'.
	tab = '\t'.

TOKENS
	ID = letter { letter | digit }.
	CTEENTERA = digit {digit}.
	CTEFLOAT = digit {digit} "." digit {digit}.
	CTESTRING = '"' letter { letter | digit } '"'.
	CTECHAR = '\'' char '\''.
	PROGRAM  = "program".
	MAIN = "main".
	VOID = "void".
	INT = "int".
	FLOAT = "float".
	STRING = "string".
	BOOL = "bool".
	CHAR = "char".
	IFF = "if".
	ELSE = "else".
	AND = "and".
	OR = "or".
	WHILE = "while".
	FOR = "for".
	RETURN = "return".
	PRINT = "print".
	READLINE = "readLine".
	FUNCTION = "function".
	TRUE = "true".
	FALSE = "false".
	REF = "ref".
	PYC = ";".
	COMA = ",".
	IGUAL = "=".
	PARAB = "(".
	PARCI = ")".
	LLAVEAB = "{".
	LLAVECI = "}".
	CORCHAB = "[".
	CORCHCI = "]".
	MAS = "+".
	MENOS = "-".
	MULT = "*".
	DIV = "/".
	MAQUE = ">".
	MEQUE = "<".
	DIFERENTE = "!=".
	COMPARACION = "==".


IGNORE cr + lf + tab



PRODUCTIONS
/*------------------------------------------------------------------------*/
/*---------------------------------------------- PLEARNING ---------------------------------------------- */
PLearning = PROGRAM
	(. 
		procedureTable = new Dictionary<string, Procedure>();
		constantTable = new Dictionary<string, Constant>(); 
	.)
 ID
 	(. 
 		actualProcedure = new Procedure(t.val, ReturnType.Program);
 		procedureTable.Add(t.val, actualProcedure);   
 		programID = t.val;
	.) 
PYC {vars}
	(.
		scopeActual = VirtualStructure.VariableType.Local;
		PSaltos.Push(quadruples.Count);
		quadruples.Add(new Quadruple(OperationCode.Goto, -1, -1, -1)); 
	.)
 {funcion} main.

/*---------------------------------------------- VARS ---------------------------------------------- */
vars = tipo
	(. 
		List<int> registros = new List<int>();
 		tipoActual = DataType.toDataType(t.val); 
 	.)
(ID 
	(.
		if (actualProcedure.VariableTable.ContainsKey(t.val))
		{
			SemErr("Error - Variable " + t.val + " previamente declarada");
		}
		else
		{
			int virtualDir = VirtualStructure.getNext(scopeActual, tipoActual);
			registros.Add(virtualDir);
			actualProcedure.VariableTable.Add(t.val, new Variable(t.val, tipoActual, virtualDir));
			actualProcedure.increaseCounter(VirtualStructure.VariableType.Local, tipoActual);
		}
  	.)
{COMA ID
 	(.
 		if (actualProcedure.VariableTable.ContainsKey(t.val))
		{
			SemErr("Error - Variable '" + t.val + "' previamente declarada");
		}
		else
		{
			int virtualDir = VirtualStructure.getNext(scopeActual, tipoActual);
			registros.Add(virtualDir);
			actualProcedure.VariableTable.Add(t.val, new Variable(t.val, tipoActual, virtualDir));
			actualProcedure.increaseCounter(VirtualStructure.VariableType.Local, tipoActual);
		} 
	.)
 } [IGUAL (ctelet | ctenum | ctebool)
	(.
		foreach (int r in registros)
		{
			quadruples.Add(new Quadruple(OperationCode.Assignment, constantTable[t.val].VirtualDir, -1, r));
		}

	.)

 ] 

|
CORCHAB CTEENTERA [ COMA CTEENTERA ] CORCHCI 
 ID
  (.
		if (actualProcedure.VariableTable.ContainsKey(t.val))
		{
			SemErr("Error - Variable '" + t.val + "' previamente declarada");
		}
		else
		{
			actualProcedure.VariableTable.Add(t.val, new Variable(t.val, tipoActual, VirtualStructure.getNext(scopeActual, tipoActual)));
		}
  	.)
{COMA ID
	(.
		if (actualProcedure.VariableTable.ContainsKey(t.val))
		{
			SemErr("Error - Variable '" + t.val + "' previamente declarada");
		}
		else
		{
			actualProcedure.VariableTable.Add(t.val, new Variable(t.val, tipoActual, VirtualStructure.getNext(scopeActual, tipoActual)));
		}
  	.)
}) PYC.


/*---------------------------------------------- FUNCION ---------------------------------------------- */
funcion = FUNCTION regresa
	(.
		int retType = ReturnType.toReturnType(t.val);
	.)
ID 
	(.
		if (procedureTable.ContainsKey(t.val))
		{
			SemErr("Error - Funcion '" + t.val + "' previamente declarada");
		}
		else
		{
			actualProcedure = new Procedure(t.val, retType);
			procedureTable.Add(t.val, actualProcedure);
		}
		
	.) 
PARAB [parametro {COMA parametro }] PARCI LLAVEAB
(.
	actualProcedure.InitialDir = quadruples.Count;
.)
{vars} {estatuto} [ RETURN expresion PYC ] LLAVECI .

/*---------------------------------------------- PARAMETRO ---------------------------------------------- */
parametro = [REF] tipo
	(.
		int type = DataType.toDataType(t.val);
		actualProcedure.Parameters.Add(type);
	.)
 ID 
 	(.
 		if (actualProcedure.VariableTable.ContainsKey(t.val))
		{
			SemErr("Variable previamente declarada");
		}
		else
		{
			actualProcedure.VariableTable.Add(t.val, new Variable(t.val, type, VirtualStructure.getNext(scopeActual, type)));
			actualProcedure.increaseCounter(VirtualStructure.VariableType.Local, type);
		}
 	.)

 [ CORCHAB CORCHCI ].

/*---------------------------------------------- MAIN ---------------------------------------------- */
main = VOID MAIN 
	(.
		actualProcedure = new Procedure("main", ReturnType.Main);
		procedureTable.Add("main", actualProcedure);
	.)
PARAB PARCI LLAVEAB 
	(.
		actualProcedure.InitialDir = quadruples.Count;
		int got = PSaltos.Pop();
		quadruples[got].TemporalRegorJump = quadruples.Count;

	.)
{vars} {estatuto} LLAVECI .

/*---------------------------------------------- REGRESA ---------------------------------------------- */
regresa = (tipo | VOID).

/*---------------------------------------------- TIPO ---------------------------------------------- */
tipo = (INT | FLOAT | STRING | BOOL | CHAR).

/*---------------------------------------------- BLOQUE ---------------------------------------------- */
bloque = LLAVEAB {estatuto} LLAVECI .

/*---------------------------------------------- CICLOWHILE ---------------------------------------------- */
ciclowhile = WHILE 
	(.
		PSaltos.Push(quadruples.Count);
	.)
PARAB expresion 
	(.
		int aux = PTipos.Pop();

		if (aux != DataType.Bool)
		{
			SemErr("Error - Se esperaba un booleano en el while");
			finishExecution();
		}
		else
		{
			int res = PilaOperandos.Pop();
			Quadruple qAux = new Quadruple(OperationCode.GotoF, res, -1, -1);
			quadruples.Add(qAux);
			PSaltos.Push(quadruples.Count - 1);

		}
	.)
PARCI bloque
(.
	int falso = PSaltos.Pop();
	int retorno = PSaltos.Pop();
	Quadruple qAux2 = new Quadruple(OperationCode.Goto, -1, -1, retorno);
	quadruples.Add(qAux2);
	quadruples[falso].TemporalRegorJump = quadruples.Count;

.)
.

/*---------------------------------------------- CICLOFOR ---------------------------------------------- */
ciclofor = FOR PARAB ID 
	(.
		tryToInsertVariable();
	.)
IGUAL 
	(.
		POper.Push(OperationCode.Assignment);
	.)
expresion
	(.
		int ladoDer = PilaOperandos.Pop();
 		int ladoIzq = PilaOperandos.Pop();

 		int tipoDer = PTipos.Pop();
 		int tipoIzq = PTipos.Pop();
 		int asigna = POper.Pop();

 		if (tipoDer == tipoIzq)
 		{			
 			Quadruple qAux = new Quadruple(asigna, ladoDer, -1, ladoIzq);
 			quadruples.Add(qAux);
 		}
 		else
 		{
 			SemErr("Error - Tipos no compatibles en asignación.");
 		}

 		PSaltos.Push(quadruples.Count);		//Pointer a antes de condición

	.)
PYC expresion 
	(.
		int res = PilaOperandos.Pop();										//Resultado de evaluar la expresión del for
		int tipo = PTipos.Pop();

		if (tipo != DataType.Bool)
		{
			SemErr("Error - Se esperaba un booleano en el for");
			finishExecution();
		}
		else
		{
			PSaltos.Push(quadruples.Count);										//Pointer para regresar al GotoF
			Quadruple qAux2 = new Quadruple(OperationCode.GotoF, res, -1, -1);	//Genera cuadrupulo del GotoF
			quadruples.Add(qAux2);
			PSaltos.Push(quadruples.Count);										//Pointer para regresar al Goto siguiente
			Quadruple qAux3 = new Quadruple(OperationCode.Goto, -1, -1, -1);	//Goto que sirve para saltar el incremento
			quadruples.Add(qAux3);
			PSaltos.Push(quadruples.Count);										//Pointer a antes del incremento
		}

		
	.)
PYC expresion 
	(.
		int res2 = PilaOperandos.Pop();													//Resultado de lo que cambia la variable
		Quadruple qAux4 = new Quadruple(OperationCode.Assignment, res2, -1, ladoIzq);	//Se asigna el resultado de la expresion a la variable de control
		quadruples.Add(qAux4);

		//Se sacan todos los datos que habiamos metido de la pila de saltos para crear el goto a antes de la condicion y rellenar el Goto que se saltaba la expresion de
		//la variable de control
		int antIncremento = PSaltos.Pop();										
		int saltoAEj = PSaltos.Pop();
		int gotoF = PSaltos.Pop();
		int antCondicion = PSaltos.Pop();

		Quadruple qAux5 = new Quadruple(OperationCode.Goto, -1, -1, antCondicion);
		quadruples.Add(qAux5);

		quadruples[saltoAEj].TemporalRegorJump = quadruples.Count;

		//Se vuelven a meter los datos no usados al stack
		PSaltos.Push(gotoF);
		PSaltos.Push(antIncremento);

	.)
PARCI bloque
	(.
		//Se saca el antes del incremento para crear un goto vaya hacia las operaciones para la variable de control
		antIncremento = PSaltos.Pop();
		Quadruple qAux6 = new Quadruple(OperationCode.Goto, -1, -1, antIncremento);
		quadruples.Add(qAux6);

		//Se rellena el GotoF hacia la siguiente instrucción a ejecutar
		gotoF = PSaltos.Pop();
		quadruples[gotoF].TemporalRegorJump = quadruples.Count;

	.)
.

/*---------------------------------------------- CICLOS ---------------------------------------------- */
ciclos = (ciclowhile | ciclofor).

/*---------------------------------------------- CONDICION ---------------------------------------------- */
condicion = IFF PARAB expresion 
	(.
		int aux = PTipos.Pop();

		if (aux != DataType.Bool)
		{
			SemErr("Error - Se esperaba un booleano en el if");
			finishExecution();
		}
		else
		{
			int res = PilaOperandos.Pop();
			Quadruple qAux = new Quadruple(OperationCode.GotoF, res, -1, -1);
			quadruples.Add(qAux);
			PSaltos.Push(quadruples.Count - 1);

		}
	.)
PARCI bloque [ELSE  
	(.
		Quadruple qAux = new Quadruple(OperationCode.Goto, -1, -1, -1);
		quadruples.Add(qAux);
		int falso = PSaltos.Pop();
		quadruples[falso].TemporalRegorJump = quadruples.Count;
		PSaltos.Push(quadruples.Count - 1);

	.)
bloque]
	(.
		int fin = PSaltos.Pop();
		quadruples[fin].TemporalRegorJump = quadruples.Count;
	.)
.

/*---------------------------------------------- ESTATUTO ---------------------------------------------- */
estatuto = (condicion | escritura | ciclos | asignacionollamada ). 

/*---------------------------------------------- LECTURA ---------------------------------------------- */
lectura = READLINE 
	(.
		int tempString = VirtualStructure.getNext(VirtualStructure.VariableType.Temporal, DataType.String);
		PilaOperandos.Push(tempString);
		PTipos.Push(DataType.String);
		Quadruple qAux = new Quadruple(OperationCode.ReadLine, -1, -1, tempString);
	.)
PARAB PARCI.

/*---------------------------------------------- ESCRITURA ---------------------------------------------- */
escritura = PRINT PARAB expresion
	(.
		int resExp = PilaOperandos.Pop();
		Quadruple qAux = new Quadruple(OperationCode.Print, -1, -1, resExp);
		quadruples.Add(qAux);
	.)

 { COMA expresion
	(.
		resExp = PilaOperandos.Pop();
		qAux = new Quadruple(OperationCode.Print, -1, -1, resExp);
		quadruples.Add(qAux);
	.)
  } PARCI PYC.

/*---------------------------------------------- ASIGNACIONOLLAMADA ---------------------------------------------- */
asignacionollamada = ID (
	(.
		tryToInsertVariable();
	.)
[cuantificador] IGUAL
	(.
		POper.Push(OperationCode.Assignment);
	.)
 (expresion | lectura) 
(.
 		int ladoDer = PilaOperandos.Pop();
 		int ladoIzq = PilaOperandos.Pop();

 		int tipoDer = PTipos.Pop();
 		int tipoIzq = PTipos.Pop();
 		int asigna = POper.Pop();

 		if (tipoDer == tipoIzq)
 		{			
 			Quadruple qAux = new Quadruple(asigna, ladoDer, -1, ladoIzq);
 			quadruples.Add(qAux);
 		}
 		else
 		{
 			SemErr("Error - Tipos no compatibles en asignación.");
 		}	
.)
 | PARAB [expresion {COMA expresion }] PARCI) PYC.

/*---------------------------------------------- CUANTIFICADOR ---------------------------------------------- */
cuantificador = CORCHAB expresion [COMA expresion ] CORCHCI.


/*---------------------------------------------- EXPRESION ---------------------------------------------- */
expresion = comparacion
	(.
		if (POper.Count > 0 && (POper.Peek() == OperationCode.And || POper.Peek() == OperationCode.Or))
		{
			tryToGenerateQuadruple();
		}
	.)
{(AND | OR) 
	(.
		POper.Push(OperationCode.toOperationCode(t.val));
	.)
comparacion
	(.
		if (POper.Count > 0 && (POper.Peek() == OperationCode.And || POper.Peek() == OperationCode.Or))
		{
			tryToGenerateQuadruple();
		}
	.)
}.

/*---------------------------------------------- COMPARACION ---------------------------------------------- */
comparacion = exp [(MAQUE | MEQUE | DIFERENTE | COMPARACION) 
	(.
		POper.Push(OperationCode.toOperationCode(t.val));
	.)
exp
	(.
		if (POper.Count > 0 && (POper.Peek() == OperationCode.MoreThan || POper.Peek() == OperationCode.LessThan || POper.Peek() == OperationCode.Different || POper.Peek() == OperationCode.EqualComparison))
		{
			tryToGenerateQuadruple();
		}
	.)
].

/*---------------------------------------------- EXP ---------------------------------------------- */
exp = term
	(.
		if (POper.Count > 0 && (POper.Peek() == OperationCode.Sum || POper.Peek() == OperationCode.Substraction))
		{
			tryToGenerateQuadruple();
		}
	.)

 {(MAS | MENOS) 
	(.
		POper.Push(OperationCode.toOperationCode(t.val));
	.)	
	term
	(.
		if (POper.Count > 0 && (POper.Peek() == OperationCode.Sum || POper.Peek() == OperationCode.Substraction))
		{
			tryToGenerateQuadruple();
		}
	.)
	}.

/*---------------------------------------------- TERM ---------------------------------------------- */
term = factor
	(.
		if (POper.Count > 0 && (POper.Peek() == OperationCode.Multiplication || POper.Peek() == OperationCode.Division))
		{
			tryToGenerateQuadruple();
		}
	.)
{(MULT | DIV) 
	(.
		POper.Push(OperationCode.toOperationCode(t.val));
	.)
factor
	(.
		if (POper.Count > 0 && (POper.Peek() == OperationCode.Multiplication || POper.Peek() == OperationCode.Division))
		{
			tryToGenerateQuadruple();
		}
	.)

}.

/*---------------------------------------------- FACTOR ---------------------------------------------- */
factor = PARAB
	(.
		POper.Push(-1);
	.)
 expresion PARCI
 	(.
 		POper.Pop();
	.)
  | [MAS | MENOS] ctevar.

/*---------------------------------------------- CTEVAR ---------------------------------------------- */
ctevar = (ctelet | ctebool | ctenum | ID
	(.
		string id = t.val;
	.)
 (PARAB [expresion {COMA expresion }] PARCI | cuantificador |
	(.
		tryToInsertVariable();
	.)
 ) ).

/*---------------------------------------------- CTELET ---------------------------------------------- */
ctelet = (CTESTRING
	(.
		tryToInsertConstant(DataType.String);
	.)
 | CTECHAR
	(.
		tryToInsertConstant(DataType.Char);
	.)
 ).

/*---------------------------------------------- CTEBOOL ---------------------------------------------- */
ctebool = (TRUE | FALSE) 
	(.
		tryToInsertConstant(DataType.Bool);
	.)
.

/*---------------------------------------------- CTENUM ---------------------------------------------- */
ctenum = (CTEENTERA 
	(.
		tryToInsertConstant(DataType.Int);
	.)
| CTEFLOAT
	(.
		tryToInsertConstant(DataType.Int);
	.)
).


/*------------------------------------------------------------------------*/


END PLearning.
